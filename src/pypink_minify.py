#!/usr/bin/python3
exec("""\n'''INITIALIZATION CODE STARTS HERE'''\n\nru, en = 'ru', 'en'\n\nimport os, platform\nfrom random import choice\ntry:\n    import atexit\nexcept ImportError:\n    raise ImportError('Library "atexit" isn'+"'"+'t installed.')\nclass main_error(Exception):\n    def __init__(self, pass_on_error = True, *args) -> None:\n        pass\nclass runtime_error(Exception):\n    def __init__(self, pass_on_error = True, *args) -> None:\n        pass\nclass import_error(Exception):\n    def __init__(self, pass_on_error = True, *args) -> None:\n        pass\nclass code_error(Exception):\n    def __init__(self, pass_on_error = True, *args) -> None:\n        pass\nclass env_error(Exception):\n    def __init__(self, pass_on_error = True, *args) -> None:\n        pass\n\n\nclass EmptyStringError(Exception):\n    def __init__(self, pass_on_error = True, *args) -> None:\n        pass\nclass InvalidStringError(Exception):\n    def __init__(self, pass_on_error = True, *args) -> None:\n        pass\nclass InvalidStringType(Exception):\n    def __init__(self, pass_on_error = True, *args) -> None:\n        pass\nclass UnsupportedStringType(Exception):\n    def __init__(self, pass_on_error = True, *args) -> None:\n        pass\nclass TooManyNotStringsInString(Exception):\n    def __init__(self, pass_on_error = True, *args) -> None:\n        pass\n\n\nclass env:\n    env_list = ['none.temporary-env-file']\n    def __init__(self, *args) -> None:\n        pass\n    def create(self = None, name = None, file = None, value = '', *args) -> None:\n        if value == '' or name == '' or file == '' or value == None or name == None or file == None:\n            raise env_error('env.create: env name / value / file name cannot be empty\\nvalues: {NAME:"'+str(name)+'",FILE:"'+str(file)+'",VALUE:"'+str(value)+'"}')\n        else:\n            if not name in env.env_list and not file in env.env_list and not file + '.temporary-env-file' in env.env_list:\n                with open(file + '.temporary-env-file', 'w') as File:\n                    File.write(str(name).replace('\\n',''))\n                    File.write('\\n'+str(value).replace('\\n',''))\n                    File.close()\n                env.env_list.append(file + '.temporary-env-file')\n            else:\n                raise env_error('env.create: env name / file name have been already declared\\nvalues: {NAME:"'+str(name)+'",FILE_NAME:"'+str(file)+'"}')\nclass __pypink__:\n    def __init__(self, *args) -> None:\n        pass\n    def exit_handler():\n        try:\n            for get_env in env.env_list:\n                try:\n                    os.remove(get_env)\n                except Exception:\n                    pass\n        except Exception:\n            pass\natexit._clear()\natexit.register(__pypink__.exit_handler)\n\n'''AND ENDS HERE. MAIN CODE STARTS HERE'''\n\ndef getargs(*args):\n    return args\ndef clear_console(cross_platform = True, *args):\n    if cross_platform == True:\n        os.system('clear || cls || :')\n    else:\n        if os.name.lower() == 'posix':\n            os.system('clear')\n        else:\n            os.system('cls')\ndef capitalize(string = None, *args):\n    is_string_empty = is_empty(string)\n    if is_string_empty == False:\n        return string.capitalize()\n    else:\n        return False\ndef is_empty(string = None, *args):\n    if string == None or string == '':# or string.startswith(' ') and string.endswith(' '):\n                                    # Removed this part due bugs and glitches\n        return True\n    else:\n        return False\ndef platform_name():\n    return str(platform.system()).lower()\ndef pip_install(lib: str, *args):\n    is_string_empty = is_empty(lib)\n    if not is_string_empty:\n        if platform_name() == 'windows':\n            os.system('py -m ensurepip --upgrade || cls; pip install '+str(lib))\n        else:\n            os.system('python -m ensurepip --upgrade || clear; pip install '+str(lib))\n    else:\n        pass\ndef crop_string(string = None, symbol = None, *args):\n    if type(string).__name__ == 'str' or type(symbol).__name__ == 'str':\n        if is_empty(string) or is_empty(string):\n            raise EmptyStringError('Excepted str, instead got '+str('NoneType with empty input'))\n        else:\n            Splitted_List = string.split(str(symbol))\n            return Splitted_List\n    if 1==1:\n        if type(string).__name__ != 'str':\n            raise InvalidStringError('Excepted str, instead got '+str(type(string).__name__))\n        elif type(symbol).__name__ != 'str':\n            raise InvalidStringError('Excepted str, instead got '+str(type(symbol).__name__))\n        else:\n            if type(symbol).__name__ == 'str' or type(string).__name__ == 'str':\n                pass\n            else:\n                raise code_error('Unexpected error: expected str, instead got NoneType and got invalid input type')\ndef llama_sh(command = 'echo "llama_sh v.1.0.0"', *args):\n    try:\n        if str(type(command).__name__) == 'str':\n            os.system(str(command))\n        else:\n            raise UnsupportedStringType('Excepted str, instead got '+str(type(command).__name__))\n    except TypeError:\n        raise TooManyNotStringsInString('Got too many invalid strings')\ndef pr(pr, raw = False, *args):\n    if raw: pr = ''.join(r'{}'.format(pr))\n    if pr != '':\n        if str(type(pr).__name__) == 'str':\n            if raw: print(r'{}'.format(pr))\n            else: print(pr)\n        else:\n            raise ValueError('Excepted "str".type, instead got "{}.type"; use str() or \\'quotes\\' converter instead'.format(str(type(pr).__name__)))\n    # A shorter and better version for "print"\ndef is_from_blacklist(string, blacklist, *args):\n    if string in blacklist:\n        return True\n    else:\n        return False\n    # Simple blacklist engine\ndef random_string(length = 0, custom_strings_list = [], *args):\n    string = ''\n    strings_list = ['A', 'B', 'C', 'D', 'E', 'F', 'G', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g']\n    if len(custom_strings_list) <= 0:\n        for x in range(length): string += choice(strings_list)\n    else:\n        for x in range(length): string += choice(custom_strings_list)\n    return string\n    # Simple random string generator\ndef custom_raise(raise_class = runtime_error, raise_description = '', exit_after = True, exit_code = 0, *args):\n    try:\n        print('The current program "'+str(get_program_name())+'" raises an error: ')\n        print('   pypink.raise(){')\n        print('   [          '+str(raise_class.__name__)+',')\n        if not is_empty(str(raise_description)):\n            print('   [          '+str(raise_description)+',')\n        else: print('   ][')\n        print(']}')\n        if exit_after:\n            try: exit(int(exit_code))\n            except BaseException: return False\n    except BaseException as e: err_crashed(code = e, confirmation = True)\ndef get_program_name(*args):\n    return str(os.path.basename(__file__))\ndef err_crashed(code = None, confirmation = False, *NoneArgs_pass):\n    if confirmation: print('\\033[0;31mpypink.Error: Crashed; "'+str(code)+str('"')+'\\033[0m');exit()\ndef alphabet(lang = 'en', *args):\n    def list_lang(lang):\n        en = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n        ru = ['а','б','в','г','д','е','ё','ж','з','и','й','к','л','м','н','о','п','р','с','т','у','ф','х','ц','ч','ш','щ','ъ','ы','ь','э','ю','я']\n        if lang == 'en':\n            return en\n        elif lang == 'ru':\n            return ru\n    if stringmngr_is_string(lang):\n        return list_lang(lang)\n    else: return False\n\ndef stringmngr_is_string(string, *args):\n    if stringmngr_is_string_is_type(string, 'str'): return True\n    else: return False\ndef stringmngr_is_int(string, *args):\n    if stringmngr_is_string_is_type(string, 'int'): return True\n    else: return False\ndef stringmngr_is_float(string, *args):\n    if stringmngr_is_string_is_type(string, 'float'): return True\n    else: return False\n\ndef stringmngr_is_string_is_type(string, is_type, *args):\n    if stringmngr_get_string_type(string) == is_type: return True\n    else: return False\ndef stringmngr_get_string_type(string, *args): return str(type(string).__name__)\n'''AND ENDS HERE.'''\n\n'''TESTING AREA IS HERE'''\n\npass\nclear_console()\n\n'''AND TESTING AREA ENDS HERE.'''\n""")
